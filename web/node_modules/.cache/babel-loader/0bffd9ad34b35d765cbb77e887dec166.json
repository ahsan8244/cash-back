{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.Tesseract = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) s(r[o]);\n\n    return s;\n  }({\n    1: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        } // if setTimeout wasn't available but was latter defined\n\n\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        } // if clearTimeout wasn't available but was latter defined\n\n\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n\n        draining = false;\n\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n\n          queueIndex = -1;\n          len = queue.length;\n        }\n\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n\n        queue.push(new Item(fun, args));\n\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      }; // v8 likes predictible objects\n\n\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {\n        return [];\n      };\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {\n        return '/';\n      };\n\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n      process.umask = function () {\n        return 0;\n      };\n    }, {}],\n    2: [function (require, module, exports) {\n      module.exports = {\n        \"name\": \"tesseract.js\",\n        \"version\": \"1.0.19\",\n        \"description\": \"Pure Javascript Multilingual OCR\",\n        \"main\": \"src/index.js\",\n        \"scripts\": {\n          \"start\": \"concurrently --kill-others \\\"watchify src/index.js  -t [ envify --TESS_ENV development ] -t [ babelify --presets [ es2015 ] ] -o dist/tesseract.dev.js --standalone Tesseract\\\" \\\"watchify src/browser/worker.js  -t [ envify --TESS_ENV development ] -t [ babelify --presets [ es2015 ] ] -o dist/worker.dev.js\\\" \\\"http-server -p 7355\\\"\",\n          \"build\": \"browserify src/index.js -t [ babelify --presets [ es2015 ] ] -o dist/tesseract.js --standalone Tesseract && browserify src/browser/worker.js -t [ babelify --presets [ es2015 ] ] -o dist/worker.js && uglifyjs dist/tesseract.js --source-map -o dist/tesseract.min.js && uglifyjs dist/worker.js --source-map -o dist/worker.min.js\",\n          \"release\": \"npm run build && git commit -am 'new release' && git push && git tag `jq -r '.version' package.json` && git push origin --tags && npm publish\"\n        },\n        \"browser\": {\n          \"./src/node/index.js\": \"./src/browser/index.js\"\n        },\n        \"author\": \"\",\n        \"license\": \"Apache-2.0\",\n        \"devDependencies\": {\n          \"babel-preset-es2015\": \"^6.16.0\",\n          \"babelify\": \"^7.3.0\",\n          \"browserify\": \"^13.1.0\",\n          \"concurrently\": \"^3.1.0\",\n          \"envify\": \"^3.4.1\",\n          \"http-server\": \"^0.9.0\",\n          \"pako\": \"^1.0.3\",\n          \"uglify-js\": \"^3.4.9\",\n          \"watchify\": \"^3.7.0\"\n        },\n        \"dependencies\": {\n          \"file-type\": \"^3.8.0\",\n          \"isomorphic-fetch\": \"^2.2.1\",\n          \"is-url\": \"1.2.2\",\n          \"jpeg-js\": \"^0.2.0\",\n          \"level-js\": \"^2.2.4\",\n          \"node-fetch\": \"^1.6.3\",\n          \"object-assign\": \"^4.1.0\",\n          \"png.js\": \"^0.2.1\",\n          \"tesseract.js-core\": \"^1.0.2\"\n        },\n        \"repository\": {\n          \"type\": \"git\",\n          \"url\": \"https://github.com/naptha/tesseract.js.git\"\n        },\n        \"bugs\": {\n          \"url\": \"https://github.com/naptha/tesseract.js/issues\"\n        },\n        \"homepage\": \"https://github.com/naptha/tesseract.js\"\n      };\n    }, {}],\n    3: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        var defaultOptions = {\n          // workerPath: 'https://cdn.jsdelivr.net/gh/naptha/tesseract.js@0.2.0/dist/worker.js',\n          corePath: 'https://cdn.jsdelivr.net/gh/naptha/tesseract.js-core@0.1.0/index.js',\n          langPath: 'https://tessdata.projectnaptha.com/3.02/'\n        };\n\n        if (process.env.TESS_ENV === \"development\") {\n          console.debug('Using Development Configuration');\n          defaultOptions.workerPath = location.protocol + '//' + location.host + '/dist/worker.dev.js?nocache=' + Math.random().toString(36).slice(3);\n        } else {\n          var version = require('../../package.json').version;\n\n          defaultOptions.workerPath = 'https://cdn.jsdelivr.net/gh/naptha/tesseract.js@' + version + '/dist/worker.js';\n        }\n\n        exports.defaultOptions = defaultOptions;\n\n        exports.spawnWorker = function spawnWorker(instance, workerOptions) {\n          if (Blob && URL) {\n            var blob = new Blob(['importScripts(\"' + workerOptions.workerPath + '\");'], {\n              type: 'application/javascript'\n            });\n            var worker = new Worker(URL.createObjectURL(blob));\n          } else {\n            var worker = new Worker(workerOptions.workerPath);\n          }\n\n          worker.onmessage = function (e) {\n            var packet = e.data;\n\n            instance._recv(packet);\n          };\n\n          return worker;\n        };\n\n        exports.terminateWorker = function (instance) {\n          instance.worker.terminate();\n        };\n\n        exports.sendPacket = function sendPacket(instance, packet) {\n          loadImage(packet.payload.image, function (img) {\n            packet.payload.image = img;\n            instance.worker.postMessage(packet);\n          });\n        };\n\n        function loadImage(image, cb) {\n          if (typeof image === 'string') {\n            if (/^\\#/.test(image)) {\n              // element css selector\n              return loadImage(document.querySelector(image), cb);\n            } else if (/(blob|data)\\:/.test(image)) {\n              // data url\n              var im = new Image();\n              im.src = image;\n\n              im.onload = function (e) {\n                return loadImage(im, cb);\n              };\n\n              im.onerror = function (e) {\n                throw e;\n              };\n\n              return;\n            } else {\n              var xhr = new XMLHttpRequest();\n              xhr.open('GET', image, true);\n              xhr.responseType = \"blob\";\n\n              xhr.onload = function (e) {\n                if (xhr.status >= 400) {\n                  throw new Error('Fail to get image as Blob');\n                } else {\n                  loadImage(xhr.response, cb);\n                }\n              };\n\n              xhr.onerror = function (e) {\n                throw e;\n              };\n\n              xhr.send(null);\n              return;\n            }\n          } else if (image instanceof File) {\n            // files\n            var fr = new FileReader();\n\n            fr.onload = function (e) {\n              return loadImage(fr.result, cb);\n            };\n\n            fr.onerror = function (e) {\n              throw e;\n            };\n\n            fr.readAsDataURL(image);\n            return;\n          } else if (image instanceof Blob) {\n            return loadImage(URL.createObjectURL(image), cb);\n          } else if (image.getContext) {\n            // canvas element\n            return loadImage(image.getContext('2d'), cb);\n          } else if (image.tagName == \"IMG\" || image.tagName == \"VIDEO\") {\n            // image element or video element\n            var c = document.createElement('canvas');\n            c.width = image.naturalWidth || image.videoWidth;\n            c.height = image.naturalHeight || image.videoHeight;\n            var ctx = c.getContext('2d');\n            ctx.drawImage(image, 0, 0);\n            return loadImage(ctx, cb);\n          } else if (image.getImageData) {\n            // canvas context\n            var data = image.getImageData(0, 0, image.canvas.width, image.canvas.height);\n            return loadImage(data, cb);\n          } else {\n            return cb(image);\n          }\n\n          throw new Error('Missing return in loadImage cascade');\n        }\n      }).call(this, require('_process'));\n    }, {\n      \"../../package.json\": 2,\n      \"_process\": 1\n    }],\n    4: [function (require, module, exports) {\n      \"use strict\"; // The result of dump.js is a big JSON tree\n      // which can be easily serialized (for instance\n      // to be sent from a webworker to the main app\n      // or through Node's IPC), but we want\n      // a (circular) DOM-like interface for walking\n      // through the data. \n\n      module.exports = function circularize(page) {\n        page.paragraphs = [];\n        page.lines = [];\n        page.words = [];\n        page.symbols = [];\n        page.blocks.forEach(function (block) {\n          block.page = page;\n          block.lines = [];\n          block.words = [];\n          block.symbols = [];\n          block.paragraphs.forEach(function (para) {\n            para.block = block;\n            para.page = page;\n            para.words = [];\n            para.symbols = [];\n            para.lines.forEach(function (line) {\n              line.paragraph = para;\n              line.block = block;\n              line.page = page;\n              line.symbols = [];\n              line.words.forEach(function (word) {\n                word.line = line;\n                word.paragraph = para;\n                word.block = block;\n                word.page = page;\n                word.symbols.forEach(function (sym) {\n                  sym.word = word;\n                  sym.line = line;\n                  sym.paragraph = para;\n                  sym.block = block;\n                  sym.page = page;\n                  sym.line.symbols.push(sym);\n                  sym.paragraph.symbols.push(sym);\n                  sym.block.symbols.push(sym);\n                  sym.page.symbols.push(sym);\n                });\n                word.paragraph.words.push(word);\n                word.block.words.push(word);\n                word.page.words.push(word);\n              });\n              line.block.lines.push(line);\n              line.page.lines.push(line);\n            });\n            para.page.paragraphs.push(para);\n          });\n        });\n        return page;\n      };\n    }, {}],\n    5: [function (require, module, exports) {\n      'use strict';\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var adapter = require('../node/index.js');\n\n      var jobCounter = 0;\n\n      module.exports = function () {\n        function TesseractJob(instance) {\n          _classCallCheck(this, TesseractJob);\n\n          this.id = 'Job-' + ++jobCounter + '-' + Math.random().toString(16).slice(3, 8);\n          this._instance = instance;\n          this._resolve = [];\n          this._reject = [];\n          this._progress = [];\n          this._finally = [];\n        }\n\n        _createClass(TesseractJob, [{\n          key: 'then',\n          value: function then(resolve, reject) {\n            if (this._resolve.push) {\n              this._resolve.push(resolve);\n            } else {\n              resolve(this._resolve);\n            }\n\n            if (reject) this.catch(reject);\n            return this;\n          }\n        }, {\n          key: 'catch',\n          value: function _catch(reject) {\n            if (this._reject.push) {\n              this._reject.push(reject);\n            } else {\n              reject(this._reject);\n            }\n\n            return this;\n          }\n        }, {\n          key: 'progress',\n          value: function progress(fn) {\n            this._progress.push(fn);\n\n            return this;\n          }\n        }, {\n          key: 'finally',\n          value: function _finally(fn) {\n            this._finally.push(fn);\n\n            return this;\n          }\n        }, {\n          key: '_send',\n          value: function _send(action, payload) {\n            adapter.sendPacket(this._instance, {\n              jobId: this.id,\n              action: action,\n              payload: payload\n            });\n          }\n        }, {\n          key: '_handle',\n          value: function _handle(packet) {\n            var data = packet.data;\n            var runFinallyCbs = false;\n\n            if (packet.status === 'resolve') {\n              if (this._resolve.length === 0) console.log(data);\n\n              this._resolve.forEach(function (fn) {\n                var ret = fn(data);\n\n                if (ret && typeof ret.then == 'function') {\n                  console.warn('TesseractJob instances do not chain like ES6 Promises. To convert it into a real promise, use Promise.resolve.');\n                }\n              });\n\n              this._resolve = data;\n\n              this._instance._dequeue();\n\n              runFinallyCbs = true;\n            } else if (packet.status === 'reject') {\n              if (this._reject.length === 0) console.error(data);\n\n              this._reject.forEach(function (fn) {\n                return fn(data);\n              });\n\n              this._reject = data;\n\n              this._instance._dequeue();\n\n              runFinallyCbs = true;\n            } else if (packet.status === 'progress') {\n              this._progress.forEach(function (fn) {\n                return fn(data);\n              });\n            } else {\n              console.warn('Message type unknown', packet.status);\n            }\n\n            if (runFinallyCbs) {\n              this._finally.forEach(function (fn) {\n                return fn(data);\n              });\n            }\n          }\n        }]);\n\n        return TesseractJob;\n      }();\n    }, {\n      \"../node/index.js\": 3\n    }],\n    6: [function (require, module, exports) {\n      'use strict';\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var adapter = require('./node/index.js');\n\n      var circularize = require('./common/circularize.js');\n\n      var TesseractJob = require('./common/job');\n\n      var version = require('../package.json').version;\n\n      var create = function create() {\n        var workerOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var worker = new TesseractWorker(Object.assign({}, adapter.defaultOptions, workerOptions));\n        worker.create = create;\n        worker.version = version;\n        return worker;\n      };\n\n      var TesseractWorker = function () {\n        function TesseractWorker(workerOptions) {\n          _classCallCheck(this, TesseractWorker);\n\n          this.worker = null;\n          this.workerOptions = workerOptions;\n          this._currentJob = null;\n          this._queue = [];\n        }\n\n        _createClass(TesseractWorker, [{\n          key: 'recognize',\n          value: function recognize(image) {\n            var _this = this;\n\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return this._delay(function (job) {\n              if (typeof options === 'string') options = {\n                lang: options\n              };\n              options.lang = options.lang || 'eng';\n\n              job._send('recognize', {\n                image: image,\n                options: options,\n                workerOptions: _this.workerOptions\n              });\n            });\n          }\n        }, {\n          key: 'detect',\n          value: function detect(image) {\n            var _this2 = this;\n\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return this._delay(function (job) {\n              job._send('detect', {\n                image: image,\n                options: options,\n                workerOptions: _this2.workerOptions\n              });\n            });\n          }\n        }, {\n          key: 'terminate',\n          value: function terminate() {\n            if (this.worker) adapter.terminateWorker(this);\n            this.worker = null;\n            this._currentJob = null;\n            this._queue = [];\n          }\n        }, {\n          key: '_delay',\n          value: function _delay(fn) {\n            var _this3 = this;\n\n            if (!this.worker) this.worker = adapter.spawnWorker(this, this.workerOptions);\n            var job = new TesseractJob(this);\n\n            this._queue.push(function (e) {\n              _this3._queue.shift();\n\n              _this3._currentJob = job;\n              fn(job);\n            });\n\n            if (!this._currentJob) this._dequeue();\n            return job;\n          }\n        }, {\n          key: '_dequeue',\n          value: function _dequeue() {\n            this._currentJob = null;\n\n            if (this._queue.length) {\n              this._queue[0]();\n            }\n          }\n        }, {\n          key: '_recv',\n          value: function _recv(packet) {\n            if (packet.status === 'resolve' && packet.action === 'recognize') {\n              packet.data = circularize(packet.data);\n            }\n\n            if (this._currentJob.id === packet.jobId) {\n              this._currentJob._handle(packet);\n            } else {\n              console.warn('Job ID ' + packet.jobId + ' not known.');\n            }\n          }\n        }]);\n\n        return TesseractWorker;\n      }();\n\n      module.exports = create();\n    }, {\n      \"../package.json\": 2,\n      \"./common/circularize.js\": 4,\n      \"./common/job\": 5,\n      \"./node/index.js\": 3\n    }]\n  }, {}, [6])(6);\n});","map":null,"metadata":{},"sourceType":"script"}